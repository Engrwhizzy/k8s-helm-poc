# k8s-helm-poc

## Description

Point of this project, this POC is to gain knowledge, train the mind in the new ways that K8S and helm(helm.sh) provide us, the developers, options to deploy, maintain, scale applications. Commands will be learned and noted, reflections will be written down and continous journey of self-improvement will be carried on.

## Commands & Logic

#### Pre

###### Export minikube ip to var:
```
export kip=$(minikube ip)
echo $kip
```
This is how we'll access our node, using this handy variable.

##### To init helm
```
helm init
```
this will install `Tiller` - server side component of `helm` which will runs inside the k8s cluster and manages releases made by `helm`. `helm` is a client side component which communicates with the k8s cluster and `tiller`.

##### Resources
In dir where `Chart.yaml` resides create dir `templates/` and put your deployments, service etc.

##### To install Chart in cluster
```
helm install --name k8s-helm-poc .
```
You must point to relative directory where `Chart.yaml` is situated. Hence `.`. `--name k8s-helm-poc` gives the release a custom name, otherwise is autogenerated.

##### To view release status and created deployment.

Using helm:
```
$ helm status k8s-helm-poc
```
Gives:
```
LAST DEPLOYED: Sun Jan 28 13:23:22 2018
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==> v1beta2/Deployment
NAME          DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE
k8s-helm-poc  1        1        1           1          19s
```
You may also view it using `kubectl`:
```
kubectl describe deployment k8s-helm-poc
```
View pods:
```
$ kubectl get pods -l app=k8s-helm-poc
```
```
NAME                            READY     STATUS    RESTARTS   AGE
k8s-helm-poc-598bbdccc9-gn9vk   1/1       Running   0          5m
```

#### Upgrading replicate count and upgrade using `helm`

Change replicateCount of deploy to 4.

And issue following command:
```
helm upgrade k8s-helm-poc .
```
This will create a new release as seen below.
```
$ helm ls
NAME        	REVISION	UPDATED                 	STATUS  	CHART             	NAMESPACE
k8s-helm-poc	2       	Sun Jan 28 13:30:57 2018	DEPLOYED	k8s-helm-poc-0.0.1	default
```
Kubectl will confirm increase of replicas.
```
$ kubectl get deploy
NAME           DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
k8s-helm-poc   4         4         4            4           9m
```

Issue following command to see response:
```
$ curl --silent $kip:31000/api/k8s | jq '.'
{
  "id": "72cdfd7f-dcdc-4622-8009-f9a232df1163",
  "message": "This is a drill",
  "version": "0.0.1"
}
```


#### Storing values in `values.yaml`
Create `values.yaml` in same dir as `Charts.yaml`.
Paste:
```
appVersion: '0.0.2'
image:
  repository: ndrw/k8s-helm-poc
```
Right now we'll upgrade image and also use variable references in `deployment.yaml`.

Issue:
```$ helm upgrade k8s-helm-poc .```

And then check with curl the app version:

```
$ curl --silent $kip:31000/api/k8s | jq '.'
{
  "id": "ffc21efc-0172-419e-8af1-2d0019bd721e",
  "message": "This is NOT a drill",
  "version": "0.0.2"
}
```

Version has been upgraded and we also used value referencing.



## Findings
None yet
## Knowledge, terms, notions

### Helm

###### Notions:
- Helm - chart manager
- Chart - packages of k8s resoureces - services, deployment, volumes, config maps - you name it.
- Release - packages above deployed to the cluster using Helm.
###### Uses:
- It's used to make releases which can be configured.
- upgrade, delete, rollout, rollback releases.
###### Helm is made of two components:
- `helm` - client side compomenent. It maybe installed on your PC, laptop or anywhere else - for example on your CI/CD machine.
- `tiller` - server side componenent - Runs inside the cluster and manages the releases.

Helm chart is a file called `Chart.yaml`(this is the exact name!!) - more about the file on official [documentation page](https://docs.helm.sh/developing_charts/#the-chart-yaml-file).
You must provide `name` and `version` - which is SemVer2!!!

### NodePort service - https://stackoverflow.com/questions/41963433/what-does-it-mean-for-a-service-to-be-of-type-nodeport-and-have-both-port-and-t

>nodePort is the port that a client outside of the cluster will "see". nodePort is opened on every node in your cluster via kube-proxy. With iptables magic Kubernetes (k8s) then routes traffic from that port to a matching service pod (even if that pod is running on a completely different node). 
port is the port your service listens on inside the cluster. Let's take this example:

```
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  ports:
  - port: 8080
    targetPort: 8070
    nodePort: 31222
    protocol: TCP 
  selector:
    component: my-service-app
```
>From inside my k8s cluster this service will be reachable via my-service.default.svc.cluster.local:8080 (service to service communication inside your cluster) and any request reaching there is forwarded to a running pod on targetPort 8070.
tagetPort is also by default the same value as port if not specified otherwise.



## Links
- https://medium.com/@gajus/the-missing-ci-cd-kubernetes-component-helm-package-manager-1fe002aac680